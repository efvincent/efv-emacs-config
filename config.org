* Evil
  The much heralded evil mode. 
  #+begin_src emacs-lisp
    ;;; package -- evil editing mode

    ;;; Commentary:
    ;;; This makes Emacs implement VIM for all intents and purposes

    ;;; Code:
    (use-package evil
      :ensure t
      :config
      (evil-mode 1))
  #+end_src
** Evil Window Management
   Setting splits below and to the right for horizontal and vertical splits respectively.
   #+begin_src emacs-lisp
     (setq evil-split-window-below t)
     (setq evil-split-window-right t)
   #+end_src
* Consider these
  Some packages to consider for the future

  | package | Notes                                |
  |---------+--------------------------------------|
  | [[https://gitlab.com/ideasman42/emacs-undo-fu][undo-fu]] | Simple, stable linear undo for emacs |
  |         |                                      |

* Windows
** Highlight Cursor on switch
   This package does a quick animation around the cursor when you switch to a window that helps you zero in on where it is. Handy, but not obtrusive.
   #+begin_src emacs-lisp
     (use-package beacon
	 :ensure t
	 :init (beacon-mode 1))
   #+end_src
  
** Highlight Current Line
   This is a nice subtle highlighting of the line where the cursor is located. Note that /nice/ and /subtle/ are dependent upon your theme. In the default theme, you can replace those with /jarring/ and /illegible/.
   Also note that in certain situations in tui mode and over =ssh= and things like that this becomes aweful again. If that becomes an issue, there are ways to execute this only if running in =gui= mode. Google it.
#+begin_src emacs-lisp
  (global-hl-line-mode t)
#+end_src

** Split and follow
   Usually when you split windows with the various control =x= commands, the cursor stays where it is. This custom function dows the split and follows the window
   #+begin_src elisp
     (defun split-and-follow-h ()
       ;; Perform the split horizontally and put the cursor in the new window
       ;; which will be below the current window
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))
     (global-set-key (kbd "C-x 2") 'split-and-follow-h)

     (defun split-and-follow-v ()
       ;; Perform the split vertically and put the cursor in the new widnow
       ;; which will be to the right of the current window
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))
     (global-set-key (kbd "C-x 3") 'split-and-follow-v)
  #+end_src

** Window Management
   My own alternate bindings to change how we switch between windows
   #+begin_src emacs-lisp
     (global-set-key (kbd "s-`") 'other-window)
     (global-set-key (kbd "s-w") 'delete-window)
   #+end_src
* Buffers
** always kill current buffer
   By default =C-x k= pulls up a menu asking what buffer to kill. I want to kill the current buffer always no prompt.
   #+begin_src elisp
     (defun kill-current-buffer ()
       (interactive)
       (kill-buffer (current-buffer)))
     (global-set-key (kbd "C-x k") 'kill-current-buffer)
   #+end_src
** auto completion
   We're going to be using company (vs autocomplete).
   #+begin_src emacs-lisp
     (use-package company
       :ensure t
       :init
       (add-hook 'after-init-hook 'global-company-mode))
   #+end_src
* Commands
** Command Completion
   =which-key= provides essential functionality; after the first key of a chord, =C-x= for example, and emacs will use the minibuffer (I think it's the minibuffer) to display all the options for completing the command. Life cannot exist in emcas for me without this little diddy.

   #+begin_src emacs-lisp
     (use-package which-key
	 :ensure t
	 :init (which-key-mode))
   #+end_src

** Confirmation
   This makes it possible to answer yes or no questions that are explicitly looking for the whole word =yes= or =no= to accept just the first letter. /speed/.

   #+begin_src emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+end_src
* Org
** Basic Config
*** Source editor in current window
    The default behavior of =C-c C-'= is to split the window and do the source editing in the new window. This command lets the source editing happen in the current org mode window - it has the effect of zooming in on the code snippet and allowing you to edit it.
   #+begin_src emacs-lisp
     (setq org-src-window-setup 'current-window)
   #+end_src
** Org Bullets
  #+begin_src emacs-lisp
    (use-package org-bullets
      :ensure t
      :config
      (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
  #+end_src

** Wrap in Org Mode
   #+begin_src emacs-lisp
     (add-hook 'org-mode-hook (lambda () (visual-line-mode t)))
   #+end_src
* Mode Line
** show line and columns
   Show both the line number and the column number in the mode line.
  #+begin_src elisp
    (line-number-mode 1)
    (column-number-mode 1)
  #+end_src
** Movement
*** Scrolling Content
    WHen scrolling beyond the bottom or top via arrows or =C-n= =C-p= respectively, emacs wants to make big jumps, which is just not the way things are done anymore especially with our fast key repeat rates. This makes scrolling the contents of a window sane and one line at a time.

   #+begin_src emacs-lisp
     (setq scroll-conservatively 100)
   #+end_src

** diminish
   Hide minor modes from the mode line
   #+begin_src emacs-lisp
     (use-package diminish
       :ensure t
       :init
       (diminish 'hungry-delete-mode)
       (diminish 'beacon-mode)
       (diminish 'which-key-mode)
       (diminish 'rainbow-mode)
       (diminish 'visual-line-mode)
       (diminish 'subword-mode))
   #+end_src
* Editing
** Normal Edit Keys
   Hrmm... this is a tough one. I believe I'll get around to learning the proper emacs keys for cut / copy / paste / undo, but for the time being I'm going to go ahead and use =cua-mode= and make my life a bit easier as I get the hang of things.

   #+begin_src emacs-lisp
     (cua-mode 1)
   #+end_src
   
** Fancy Substition, for example Lambda
   This is a cool one - replaces the word =lambda= with the actual lambda characer /visually/, meaning the word =lambda= is still in the file, it just looks super cool.

   #+begin_src emacs-lisp
     (global-prettify-symbols-mode t) 
   #+end_src

** Show Colors in Code
   When you put a color in source code, typically hex style like you see in web development, make the background that actual color and the foreground something that will contrast it and keep it visible. Note this works for more than just hex colors, see the docs for more info.
  #+begin_src emacs-lisp
    (use-package rainbow-mode
      :ensure t
      :init (rainbow-mode 1))
  #+end_src  
** Rainbow Delimiters
   #+begin_src emacs-lisp
     (use-package rainbow-delimiters
       :ensure t
       :init
       (add-hook 'prog-mode-hook #'rainbow-delimiters-mode 1))
   #+end_src
* General Quality ofLife
** My God with the bell
   There's never a reason for this annoyingly shittly little sound to ever be heard and I'm sad that I've had to invest time killing it with fire.

  #+begin_src emacs-lisp
    (setq ring-bell-function 'ignore)
  #+end_src

** Don't create junk files
   Emacs wants to create backup and recovery files which are annoying and will make an untidy mess of things. This stops that crap from happening.

   #+begin_src emacs-lisp
     (setq make-backup-files nil)
     (setq auto-save-default nil)
   #+end_src

** Get Rid of Extra Window Chrome
   This mostly applies to the =gui= mode but some of it includes terminal mode. No menu bar, tool bar, splash screen, etc. Self explanitory.

   #+begin_src emacs-lisp
     (tool-bar-mode -1)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
     (setq inhibit-splash-screen t)
   #+end_src

** Electric Parens
   #+begin_src emacs-lisp
     (setq electric-pair-pairs '(
				 (?\( . ?\))
				 (?\[ . ?\])
				 (?\{ . ?\})
				 )
	   )
     (electric-pair-mode t)
   #+end_src
** dashboard
   #+begin_src emacs-lisp
     (use-package dashboard
       :ensure t
       :config
       (dashboard-setup-startup-hook)
       (setq dashboard-items '((recents . 10)))
       (setq dashboard-startup-banner "~/.emacs.d/images/Haskell-Logo.png"))
   #+end_src
** clock
   #+begin_src emacs-lisp
     (display-time-mode 1)
   #+end_src
** ESC acts like C-g
   #+begin_src emacs-lisp
     (define-key key-translation-map (kbd "ESC") (kbd "C-g"))
   #+end_src
** Relative Line Numbers Everywhere
   #+begin_src emacs-lisp
     (menu-bar--display-line-numbers-mode-relative)
     (global-display-line-numbers-mode t)
   #+end_src
** Maximize the Window
   #+begin_src emacs-lisp
     (add-to-list 'default-frame-alist '(fullscreen . maximized))
   #+end_src
** Open a file with command O
   #+begin_src emacs-lisp
     (global-set-key (kbd "s-o") 'helm-find-files)
   #+end_src
* Config edit/reload
** edit
   Find and open the =config.org= file where we'll modify our emacs configuation.
   #+begin_src emacs-lisp
     (defun config-visit ()
       (interactive)
       (find-file "~/.emacs.d/config.org"))
     (global-set-key (kbd "C-c e") 'config-visit)
   #+end_src
** reload
   Extracts the emacs lisp from the =config.org= Org mode configuration file and executes it. Saves a bunch of steps when adjusting our config.
   #+begin_src emacs-lisp
     (defun config-reload ()
       (interactive)
       (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
     (global-set-key (kbd "C-c r") 'config-reload)
   #+end_src

* Helm
  #+begin_src emacs-lisp
    (use-package helm
      :init
	(require 'helm-config)
	(setq helm-split-window-in-side-p t
	      helm-move-to-line-cycle-in-source t)
      :config 
	(helm-mode 1)							;; Most of Emacs prompts become helm-enabled
	(helm-autoresize-mode 1)					;; Helm resizes according to the number of candidates
	(global-set-key (kbd "C-x b")	'helm-buffers-list)		;; List buffers ( Emacs way )
	(define-key evil-ex-map "b"	'helm-buffers-list)		;; List buffers ( Vim way )
	(global-set-key (kbd "C-x r b") 'helm-bookmarks)		;; Bookmarks menu
	(global-set-key (kbd "C-x C-f") 'helm-find-files)		;; Finding files with Helm
	(global-set-key (kbd "M-c")	'helm-calcul-expression)	;; Use Helm for calculations
	(global-set-key (kbd "C-s")	'helm-occur)			;; Replaces the default isearch keybinding
	(global-set-key (kbd "C-h a")	'helm-apropos)			;; Helmized apropos interface
	(global-set-key (kbd "M-x")	'helm-M-x)			;; Improved M-x menu
	(global-set-key (kbd "M-y")	'helm-show-kill-ring)		;; Show kill ring, pick something to paste
      :ensure t)

    ;; when arrowing in helm choices, wrap around bottom and top
    (setq helm-move-to-line-cycle-in-source t)

    ;; helm use minibuffer; less disruptive
    (setq helm-split-window-in-side-p t)
  #+end_src
  
* Terminal Mode
** VTerm
   Using the alpha quality vterm. Note that when first installing it appears to need to build another package and will prompt you to build that other package. Further, it needs to have =CMake= installed (which is probably installed on my machines). This makes the drop and play aspect of this config less of a possibility, but I'm putting terminal at the end of the config so it runs last-ish.
   #+BEGIN_SRC emacs-lisp
     (use-package vterm
       :ensure t)
   #+END_SRC
** Set the super key combo to launch a terminal
   The sets up the key combo =<super ret>= to launch =vterm=. The idea of a /super/ key is from when there were keyboards and hardware specifically for working with lisp, which is interesting and cool, but of course I've never even seen a keyboard with a super key so there's that. [[http://ergoemacs.org/emacs/emacs_hyper_super_keys.html][This post]] has details on super key and mac. Current the command key acts as the super key so long as there's no conflict with an existing command combo, and I'm not sure if it works in terminal mode.

   #+begin_src emacs-lisp
     (global-set-key (kbd "<s-return>") 'vterm)
   #+end_src

** Set Key Environment Variables
   There's a quirk that causes the path to not be set correctly when launching =zsh= from =ansi-terminal=. This package solves this by getting the values from the shell.
   And it works! This is the first thing I went off and solved by myself that wasn't part of some tutorial. /Actually/, not true. I fixed =visual-line-mode= in org mode too, but that was just stock emacs so not that impressive.
   With this, terminal is somewhat useful.

   #+begin_src emacs-lisp
     (use-package exec-path-from-shell
       :ensure t
       :init
       (exec-path-from-shell-initialize))
   #+end_src
   
* Theme
  #+begin_src emacs-lisp
    (use-package nimbus-theme
      :ensure t)
  #+end_src
* Projecs and Languages
** Language Server

   Installs language server, universally used by most languages.
     #+begin_src emacs-lisp
       (use-package lsp-mode
	 :init
	 ;; set prefix for lsp-command-keymap (few alternatives - "C-l", "C-c l")
	 (setq lsp-keymap-prefix "C-c l")
	 :hook (
	   (haskell-mode . lsp)
	   (lsp-mode . lsp-enable-which-key-integration))
	       :commands lsp)

	      ;; optionally
	      (use-package lsp-ui
		:ensure t
		:commands lsp-ui-mode)

	      ;; if you are helm user
	      (use-package helm-lsp
		:ensure t
		:commands helm-lsp-workspace-symbol)

	      (use-package lsp-treemacs
		:ensure t
	:commands lsp-treemacs-errors-list)

       (setq lsp-ui-doc-max-height 50)
       (setq lsp-ui-doc-show-with-mouse t)

  #+end_src

** FlyCheck
   On the fly syntax checking used by lsp for haskell
   #+begin_src emacs-lisp
     (use-package flycheck
       :ensure t
       :init (global-flycheck-mode))
   #+end_src
** Projectile

   For managing projects

   #+begin_src emacs-lisp
     (use-package projectile
       :ensure t
       :init
       (projectile-mode +1)
       :bind (:map projectile-mode-map
		   ;; replaces ns-print-buffer binding
		   ("s-p" . projectile-command-map)
		   ("C-c p" . projectile-command-map)))
   #+end_src
   
** Haskell Language Server

   Provides the glue between emacs language server mode and Haskell's language server which runs as a separate process outside of emacs.

   #+begin_src emacs-lisp
     (use-package lsp-haskell
       :ensure t)

     (add-hook 'haskell-mode-hook #'lsp)
     (add-hook 'haskell-literate-mode-hook #'lsp)
   #+end_src

* Treemacs
  #+begin_src emacs-lisp
    ;;; Package --- Treemacs for hierarchical file organization
    ;;; Commentary: Creates a more IDE like coding experience
    ;;; Code:
    (use-package treemacs
      :ensure t
      :defer t
      :init
      (with-eval-after-load 'winum
	(define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
      :config
      (progn
	(setq treemacs-collapse-dirs                 (if treemacs-python-executable 3 0)
	      treemacs-deferred-git-apply-delay      0.5
	      treemacs-directory-name-transformer    #'identity
	      treemacs-display-in-side-window        t
	      treemacs-eldoc-display                 t
	      treemacs-file-event-delay              5000
	      treemacs-file-extension-regex          treemacs-last-period-regex-value
	      treemacs-file-follow-delay             0.2
	      treemacs-file-name-transformer         #'identity
	      treemacs-follow-after-init             t
	      treemacs-expand-after-init             t
	      treemacs-git-command-pipe              ""
	      treemacs-goto-tag-strategy             'refetch-index
	      treemacs-indentation                   2
	      treemacs-indentation-string            " "
	      treemacs-is-never-other-window         nil
	      treemacs-max-git-entries               5000
	      treemacs-missing-project-action        'ask
	      treemacs-move-forward-on-expand        nil
	      treemacs-no-png-images                 nil
	      treemacs-no-delete-other-windows       t
	      treemacs-project-follow-cleanup        nil
	      treemacs-persist-file                  (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
	      treemacs-position                      'left
	      treemacs-read-string-input             'from-child-frame
	      treemacs-recenter-distance             0.1
	      treemacs-recenter-after-file-follow    nil
	      treemacs-recenter-after-tag-follow     nil
	      treemacs-recenter-after-project-jump   'always
	      treemacs-recenter-after-project-expand 'on-distance
	      treemacs-litter-directories            '("/node_modules" "/.venv" "/.cask")
	      treemacs-show-cursor                   nil
	      treemacs-show-hidden-files             t
	      treemacs-silent-filewatch              nil
	      treemacs-silent-refresh                nil
	      treemacs-sorting                       'alphabetic-asc
	      treemacs-space-between-root-nodes      t
	      treemacs-tag-follow-cleanup            t
	      treemacs-tag-follow-delay              1.5
	      treemacs-user-mode-line-format         nil
	      treemacs-user-header-line-format       nil
	      treemacs-width                         35
	      treemacs-workspace-switch-cleanup      nil)

	;; The default width and height of the icons is 22 pixels. If you are
	;; using a Hi-DPI display, uncomment this to double the icon size.
	;;(treemacs-resize-icons 44)

	(treemacs-follow-mode t)
	(treemacs-filewatch-mode t)
	(treemacs-fringe-indicator-mode 'always)
	(pcase (cons (not (null (executable-find "git")))
		     (not (null treemacs-python-executable)))
	  (`(t . t)
	   (treemacs-git-mode 'deferred))
	  (`(t . _)
	   (treemacs-git-mode 'simple))))
      :bind
      (:map global-map
	    ("M-0"       . treemacs-select-window)
	    ("C-x t 1"   . treemacs-delete-other-windows)
	    ("C-x t t"   . treemacs)
	    ("C-x t B"   . treemacs-bookmark)
	    ("C-x t C-t" . treemacs-find-file)
	    ("C-x t M-t" . treemacs-find-tag)))

    (use-package treemacs-evil
      :after (treemacs evil)
      :ensure t)

    (use-package treemacs-projectile
      :after (treemacs projectile)
      :ensure t)

    (use-package treemacs-icons-dired
      :after (treemacs dired)
      :ensure t
      :config (treemacs-icons-dired-mode))

    (use-package treemacs-magit
      :after (treemacs magit)
      :ensure t)

    ;; (use-package treemacs-persp ;;treemacs-perspective if you use perspective.el vs. persp-mode
    ;;   :after (treemacs persp-mode) ;;or perspective vs. persp-mode
    ;;   :ensure t
    ;;   :config (treemacs-set-scope-type 'Perspectives))
  #+end_src
